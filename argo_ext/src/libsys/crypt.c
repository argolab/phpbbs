/* Copyright (C) 1995-1997 Eric Young (eay@cryptsoft.com)
 * All rights reserved.
 *
 * This package is an SSL implementation written
 * by Eric Young (eay@cryptsoft.com).
 * The implementation was written so as to conform with Netscapes SSL.
 *
 * This library is free for commercial and non-commercial use as long as
 * the following conditions are aheared to.  The following conditions
 * apply to all code found in this distribution, be it the RC4, RSA,
 * lhash, DES, etc., code; not just the SSL code.  The SSL documentation
 * included with this distribution is covered by the same copyright terms
 * except that the holder is Tim Hudson (tjh@cryptsoft.com).
 *
 * Copyright remains Eric Young's, and as such any Copyright notices in
 * the code are not to be removed.
 * If this package is used in a product, Eric Young should be given attribution
 * as the author of the parts of the library used.
 * This can be in the form of a textual message at program startup or
 * in documentation (online or textual) provided with the package.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *    "This product includes cryptographic software written by
 *     Eric Young (eay@cryptsoft.com)"
 *    The word 'cryptographic' can be left out if the rouines from the library
 *    being used are not cryptographic related :-).
 * 4. If you include any Windows specific code (or a derivative thereof) from
 *    the apps directory (application code) you must include an acknowledgement:
 *    "This product includes software written by Tim Hudson (tjh@cryptsoft.com)"
 *
 * THIS SOFTWARE IS PROVIDED BY ERIC YOUNG ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 * The licence and distribution terms for any publically available version or
 * derivative of this code cannot be changed.  i.e. this code cannot simply be
 * copied and put under another distribution licence
 * [including the GNU Public Licence.]
 */

/* monster: this file was generated by cpp 2.96 with a linux 2.4.8-ac8 box */

typedef unsigned char *POINTER;

typedef unsigned short int UINT2;

typedef unsigned long int UINT4;

typedef struct {
	unsigned long A, B, C, D;
	unsigned long Nl, Nh;
	unsigned long data[16];
	int num;
} MD5_CTX;

void MD5Init(MD5_CTX *);
void MD5Update(MD5_CTX *, const unsigned char *, unsigned int);
void MD5Final(MD5_CTX *, unsigned char[16]);

static void md5_block(MD5_CTX * c, unsigned long *p);

void
MD5Init(MD5_CTX * c)
{
	c->A = (unsigned long) 0x67452301L;
	c->B = (unsigned long) 0xefcdab89L;
	c->C = (unsigned long) 0x98badcfeL;
	c->D = (unsigned long) 0x10325476L;
	c->Nl = 0;
	c->Nh = 0;
	c->num = 0;
}

void
MD5Update(MD5_CTX * c, const unsigned char *data, unsigned int len)
{
	register unsigned long *p;
	int sw, sc;
	unsigned long l;

	if (len == 0)
		return;

	l = (c->Nl + (len << 3)) & 0xffffffffL;

	if (l < c->Nl)
		c->Nh++;
	c->Nh += (len >> 29);
	c->Nl = l;

	if (c->num != 0) {
		p = c->data;
		sw = c->num >> 2;
		sc = c->num & 0x03;

		if ((c->num + len) >= 64) {
			l = p[sw];
			{
				switch (sc) {
				case 0:
					l = ((unsigned long) (*((data)++)));
				case 1:
					l |= ((unsigned long) (*((data)++))) <<
					    8;
				case 2:
					l |= ((unsigned long) (*((data)++))) <<
					    16;
				case 3:
					l |= ((unsigned long) (*((data)++))) <<
					    24;
			}};
			p[sw++] = l;
			for (; sw < 16; sw++) {
				(l = ((unsigned long) (*((data)++))), l |=
				 (((unsigned long) (*((data)++))) << 8), l |=
				 (((unsigned long) (*((data)++))) << 16), l |=
				 (((unsigned long) (*((data)++))) << 24));
				p[sw] = l;
			}
			len -= (64 - c->num);

			md5_block(c, p);
			c->num = 0;

		} else {
			int ew, ec;

			c->num += (int) len;
			if ((sc + len) < 4) {
				l = p[sw];
				{
					switch (sc) {
					case 0:
						l = ((unsigned
						      long) (*((data)++)));
						if (--len == 0)
							break;
					case 1:
						l |= ((unsigned
						       long) (*((data)++))) <<
						    8;
						if (--len == 0)
							break;
					case 2:
						l |= ((unsigned
						       long) (*((data)++))) <<
						    16;
				}};
				p[sw] = l;
			} else {
				ew = (c->num >> 2);
				ec = (c->num & 0x03);
				l = p[sw];
				{
					switch (sc) {
					case 0:
						l = ((unsigned
						      long) (*((data)++)));
					case 1:
						l |= ((unsigned
						       long) (*((data)++))) <<
						    8;
					case 2:
						l |= ((unsigned
						       long) (*((data)++))) <<
						    16;
					case 3:
						l |= ((unsigned
						       long) (*((data)++))) <<
						    24;
				}};
				p[sw++] = l;
				for (; sw < ew; sw++) {
					(l =
					 ((unsigned long) (*((data)++))), l |=
					 (((unsigned long) (*((data)++))) << 8),
					 l |=
					 (((unsigned long) (*((data)++))) <<
					  16), l |=
					 (((unsigned long) (*((data)++))) <<
					  24));
					p[sw] = l;
				}
				if (ec) {
					{
						l = 0;
						(data) += ec;
						switch (ec) {
						case 3:
							l = ((unsigned
							      long) (*(--
								       (data))))
							    << 16;
						case 2:
							l |= ((unsigned
							       long) (*(--
									(data))))
							    << 8;
						case 1:
							l |= ((unsigned
							       long) (*(--
									(data))));
					}};
					p[sw] = l;
				}
			}
			return;
		}
	}

	p = c->data;
	while (len >= 64) {
		for (sw = (16 / 4); sw; sw--) {
			(l = ((unsigned long) (*((data)++))), l |=
			 (((unsigned long) (*((data)++))) << 8), l |=
			 (((unsigned long) (*((data)++))) << 16), l |=
			 (((unsigned long) (*((data)++))) << 24));
			*(p++) = l;
			(l = ((unsigned long) (*((data)++))), l |=
			 (((unsigned long) (*((data)++))) << 8), l |=
			 (((unsigned long) (*((data)++))) << 16), l |=
			 (((unsigned long) (*((data)++))) << 24));
			*(p++) = l;
			(l = ((unsigned long) (*((data)++))), l |=
			 (((unsigned long) (*((data)++))) << 8), l |=
			 (((unsigned long) (*((data)++))) << 16), l |=
			 (((unsigned long) (*((data)++))) << 24));
			*(p++) = l;
			(l = ((unsigned long) (*((data)++))), l |=
			 (((unsigned long) (*((data)++))) << 8), l |=
			 (((unsigned long) (*((data)++))) << 16), l |=
			 (((unsigned long) (*((data)++))) << 24));
			*(p++) = l;
		}

		p = c->data;
		md5_block(c, p);
		len -= 64;
	}
	sc = (int) len;
	c->num = sc;
	if (sc) {
		sw = sc >> 2;

		sc &= 0x03;
		for (; sw; sw--) {
			(l = ((unsigned long) (*((data)++))), l |=
			 (((unsigned long) (*((data)++))) << 8), l |=
			 (((unsigned long) (*((data)++))) << 16), l |=
			 (((unsigned long) (*((data)++))) << 24));
			*(p++) = l;
		}
		{
			l = 0;
			(data) += sc;
			switch (sc) {
			case 3:
				l = ((unsigned long) (*(--(data)))) << 16;
			case 2:
				l |= ((unsigned long) (*(--(data)))) << 8;
			case 1:
				l |= ((unsigned long) (*(--(data))));
		}};
		*p = l;

	}
}

static void
md5_block(MD5_CTX * c, register unsigned long *X)
{
	register unsigned long A, B, C, D;

	A = c->A;
	B = c->B;
	C = c->C;
	D = c->D;

	{
		A += ((X[0]) + (0xd76aa478L) +
		      (((((C)) ^ ((D))) & ((B))) ^ ((D))));
		A = (((A) << (7)) | (((A) & 0xffffffff) >> (32 - (7))));
		A += B;
	};;
	{
		D += ((X[1]) + (0xe8c7b756L) +
		      (((((B)) ^ ((C))) & ((A))) ^ ((C))));
		D = (((D) << (12)) | (((D) & 0xffffffff) >> (32 - (12))));
		D += A;
	};;
	{
		C += ((X[2]) + (0x242070dbL) +
		      (((((A)) ^ ((B))) & ((D))) ^ ((B))));
		C = (((C) << (17)) | (((C) & 0xffffffff) >> (32 - (17))));
		C += D;
	};;
	{
		B += ((X[3]) + (0xc1bdceeeL) +
		      (((((D)) ^ ((A))) & ((C))) ^ ((A))));
		B = (((B) << (22)) | (((B) & 0xffffffff) >> (32 - (22))));
		B += C;
	};;
	{
		A += ((X[4]) + (0xf57c0fafL) +
		      (((((C)) ^ ((D))) & ((B))) ^ ((D))));
		A = (((A) << (7)) | (((A) & 0xffffffff) >> (32 - (7))));
		A += B;
	};;
	{
		D += ((X[5]) + (0x4787c62aL) +
		      (((((B)) ^ ((C))) & ((A))) ^ ((C))));
		D = (((D) << (12)) | (((D) & 0xffffffff) >> (32 - (12))));
		D += A;
	};;
	{
		C += ((X[6]) + (0xa8304613L) +
		      (((((A)) ^ ((B))) & ((D))) ^ ((B))));
		C = (((C) << (17)) | (((C) & 0xffffffff) >> (32 - (17))));
		C += D;
	};;
	{
		B += ((X[7]) + (0xfd469501L) +
		      (((((D)) ^ ((A))) & ((C))) ^ ((A))));
		B = (((B) << (22)) | (((B) & 0xffffffff) >> (32 - (22))));
		B += C;
	};;
	{
		A += ((X[8]) + (0x698098d8L) +
		      (((((C)) ^ ((D))) & ((B))) ^ ((D))));
		A = (((A) << (7)) | (((A) & 0xffffffff) >> (32 - (7))));
		A += B;
	};;
	{
		D += ((X[9]) + (0x8b44f7afL) +
		      (((((B)) ^ ((C))) & ((A))) ^ ((C))));
		D = (((D) << (12)) | (((D) & 0xffffffff) >> (32 - (12))));
		D += A;
	};;
	{
		C += ((X[10]) + (0xffff5bb1L) +
		      (((((A)) ^ ((B))) & ((D))) ^ ((B))));
		C = (((C) << (17)) | (((C) & 0xffffffff) >> (32 - (17))));
		C += D;
	};;
	{
		B += ((X[11]) + (0x895cd7beL) +
		      (((((D)) ^ ((A))) & ((C))) ^ ((A))));
		B = (((B) << (22)) | (((B) & 0xffffffff) >> (32 - (22))));
		B += C;
	};;
	{
		A += ((X[12]) + (0x6b901122L) +
		      (((((C)) ^ ((D))) & ((B))) ^ ((D))));
		A = (((A) << (7)) | (((A) & 0xffffffff) >> (32 - (7))));
		A += B;
	};;
	{
		D += ((X[13]) + (0xfd987193L) +
		      (((((B)) ^ ((C))) & ((A))) ^ ((C))));
		D = (((D) << (12)) | (((D) & 0xffffffff) >> (32 - (12))));
		D += A;
	};;
	{
		C += ((X[14]) + (0xa679438eL) +
		      (((((A)) ^ ((B))) & ((D))) ^ ((B))));
		C = (((C) << (17)) | (((C) & 0xffffffff) >> (32 - (17))));
		C += D;
	};;
	{
		B += ((X[15]) + (0x49b40821L) +
		      (((((D)) ^ ((A))) & ((C))) ^ ((A))));
		B = (((B) << (22)) | (((B) & 0xffffffff) >> (32 - (22))));
		B += C;
	};;

	{
		A += ((X[1]) + (0xf61e2562L) +
		      (((((B)) ^ ((C))) & ((D))) ^ ((C))));
		A = (((A) << (5)) | (((A) & 0xffffffff) >> (32 - (5))));
		A += B;
	};;
	{
		D += ((X[6]) + (0xc040b340L) +
		      (((((A)) ^ ((B))) & ((C))) ^ ((B))));
		D = (((D) << (9)) | (((D) & 0xffffffff) >> (32 - (9))));
		D += A;
	};;
	{
		C += ((X[11]) + (0x265e5a51L) +
		      (((((D)) ^ ((A))) & ((B))) ^ ((A))));
		C = (((C) << (14)) | (((C) & 0xffffffff) >> (32 - (14))));
		C += D;
	};;
	{
		B += ((X[0]) + (0xe9b6c7aaL) +
		      (((((C)) ^ ((D))) & ((A))) ^ ((D))));
		B = (((B) << (20)) | (((B) & 0xffffffff) >> (32 - (20))));
		B += C;
	};;
	{
		A += ((X[5]) + (0xd62f105dL) +
		      (((((B)) ^ ((C))) & ((D))) ^ ((C))));
		A = (((A) << (5)) | (((A) & 0xffffffff) >> (32 - (5))));
		A += B;
	};;
	{
		D += ((X[10]) + (0x02441453L) +
		      (((((A)) ^ ((B))) & ((C))) ^ ((B))));
		D = (((D) << (9)) | (((D) & 0xffffffff) >> (32 - (9))));
		D += A;
	};;
	{
		C += ((X[15]) + (0xd8a1e681L) +
		      (((((D)) ^ ((A))) & ((B))) ^ ((A))));
		C = (((C) << (14)) | (((C) & 0xffffffff) >> (32 - (14))));
		C += D;
	};;
	{
		B += ((X[4]) + (0xe7d3fbc8L) +
		      (((((C)) ^ ((D))) & ((A))) ^ ((D))));
		B = (((B) << (20)) | (((B) & 0xffffffff) >> (32 - (20))));
		B += C;
	};;
	{
		A += ((X[9]) + (0x21e1cde6L) +
		      (((((B)) ^ ((C))) & ((D))) ^ ((C))));
		A = (((A) << (5)) | (((A) & 0xffffffff) >> (32 - (5))));
		A += B;
	};;
	{
		D += ((X[14]) + (0xc33707d6L) +
		      (((((A)) ^ ((B))) & ((C))) ^ ((B))));
		D = (((D) << (9)) | (((D) & 0xffffffff) >> (32 - (9))));
		D += A;
	};;
	{
		C += ((X[3]) + (0xf4d50d87L) +
		      (((((D)) ^ ((A))) & ((B))) ^ ((A))));
		C = (((C) << (14)) | (((C) & 0xffffffff) >> (32 - (14))));
		C += D;
	};;
	{
		B += ((X[8]) + (0x455a14edL) +
		      (((((C)) ^ ((D))) & ((A))) ^ ((D))));
		B = (((B) << (20)) | (((B) & 0xffffffff) >> (32 - (20))));
		B += C;
	};;
	{
		A += ((X[13]) + (0xa9e3e905L) +
		      (((((B)) ^ ((C))) & ((D))) ^ ((C))));
		A = (((A) << (5)) | (((A) & 0xffffffff) >> (32 - (5))));
		A += B;
	};;
	{
		D += ((X[2]) + (0xfcefa3f8L) +
		      (((((A)) ^ ((B))) & ((C))) ^ ((B))));
		D = (((D) << (9)) | (((D) & 0xffffffff) >> (32 - (9))));
		D += A;
	};;
	{
		C += ((X[7]) + (0x676f02d9L) +
		      (((((D)) ^ ((A))) & ((B))) ^ ((A))));
		C = (((C) << (14)) | (((C) & 0xffffffff) >> (32 - (14))));
		C += D;
	};;
	{
		B += ((X[12]) + (0x8d2a4c8aL) +
		      (((((C)) ^ ((D))) & ((A))) ^ ((D))));
		B = (((B) << (20)) | (((B) & 0xffffffff) >> (32 - (20))));
		B += C;
	};;

	{
		A += ((X[5]) + (0xfffa3942L) + (((B)) ^ ((C)) ^ ((D))));
		A = (((A) << (4)) | (((A) & 0xffffffff) >> (32 - (4))));
		A += B;
	};;
	{
		D += ((X[8]) + (0x8771f681L) + (((A)) ^ ((B)) ^ ((C))));
		D = (((D) << (11)) | (((D) & 0xffffffff) >> (32 - (11))));
		D += A;
	};;
	{
		C += ((X[11]) + (0x6d9d6122L) + (((D)) ^ ((A)) ^ ((B))));
		C = (((C) << (16)) | (((C) & 0xffffffff) >> (32 - (16))));
		C += D;
	};;
	{
		B += ((X[14]) + (0xfde5380cL) + (((C)) ^ ((D)) ^ ((A))));
		B = (((B) << (23)) | (((B) & 0xffffffff) >> (32 - (23))));
		B += C;
	};;
	{
		A += ((X[1]) + (0xa4beea44L) + (((B)) ^ ((C)) ^ ((D))));
		A = (((A) << (4)) | (((A) & 0xffffffff) >> (32 - (4))));
		A += B;
	};;
	{
		D += ((X[4]) + (0x4bdecfa9L) + (((A)) ^ ((B)) ^ ((C))));
		D = (((D) << (11)) | (((D) & 0xffffffff) >> (32 - (11))));
		D += A;
	};;
	{
		C += ((X[7]) + (0xf6bb4b60L) + (((D)) ^ ((A)) ^ ((B))));
		C = (((C) << (16)) | (((C) & 0xffffffff) >> (32 - (16))));
		C += D;
	};;
	{
		B += ((X[10]) + (0xbebfbc70L) + (((C)) ^ ((D)) ^ ((A))));
		B = (((B) << (23)) | (((B) & 0xffffffff) >> (32 - (23))));
		B += C;
	};;
	{
		A += ((X[13]) + (0x289b7ec6L) + (((B)) ^ ((C)) ^ ((D))));
		A = (((A) << (4)) | (((A) & 0xffffffff) >> (32 - (4))));
		A += B;
	};;
	{
		D += ((X[0]) + (0xeaa127faL) + (((A)) ^ ((B)) ^ ((C))));
		D = (((D) << (11)) | (((D) & 0xffffffff) >> (32 - (11))));
		D += A;
	};;
	{
		C += ((X[3]) + (0xd4ef3085L) + (((D)) ^ ((A)) ^ ((B))));
		C = (((C) << (16)) | (((C) & 0xffffffff) >> (32 - (16))));
		C += D;
	};;
	{
		B += ((X[6]) + (0x04881d05L) + (((C)) ^ ((D)) ^ ((A))));
		B = (((B) << (23)) | (((B) & 0xffffffff) >> (32 - (23))));
		B += C;
	};;
	{
		A += ((X[9]) + (0xd9d4d039L) + (((B)) ^ ((C)) ^ ((D))));
		A = (((A) << (4)) | (((A) & 0xffffffff) >> (32 - (4))));
		A += B;
	};;
	{
		D += ((X[12]) + (0xe6db99e5L) + (((A)) ^ ((B)) ^ ((C))));
		D = (((D) << (11)) | (((D) & 0xffffffff) >> (32 - (11))));
		D += A;
	};;
	{
		C += ((X[15]) + (0x1fa27cf8L) + (((D)) ^ ((A)) ^ ((B))));
		C = (((C) << (16)) | (((C) & 0xffffffff) >> (32 - (16))));
		C += D;
	};;
	{
		B += ((X[2]) + (0xc4ac5665L) + (((C)) ^ ((D)) ^ ((A))));
		B = (((B) << (23)) | (((B) & 0xffffffff) >> (32 - (23))));
		B += C;
	};;

	{
		A += ((X[0]) + (0xf4292244L) + ((((B)) | (~((D)))) ^ ((C))));
		A = (((A) << (6)) | (((A) & 0xffffffff) >> (32 - (6))));
		A += B;
	};;
	{
		D += ((X[7]) + (0x432aff97L) + ((((A)) | (~((C)))) ^ ((B))));
		D = (((D) << (10)) | (((D) & 0xffffffff) >> (32 - (10))));
		D += A;
	};;
	{
		C += ((X[14]) + (0xab9423a7L) + ((((D)) | (~((B)))) ^ ((A))));
		C = (((C) << (15)) | (((C) & 0xffffffff) >> (32 - (15))));
		C += D;
	};;
	{
		B += ((X[5]) + (0xfc93a039L) + ((((C)) | (~((A)))) ^ ((D))));
		B = (((B) << (21)) | (((B) & 0xffffffff) >> (32 - (21))));
		B += C;
	};;
	{
		A += ((X[12]) + (0x655b59c3L) + ((((B)) | (~((D)))) ^ ((C))));
		A = (((A) << (6)) | (((A) & 0xffffffff) >> (32 - (6))));
		A += B;
	};;
	{
		D += ((X[3]) + (0x8f0ccc92L) + ((((A)) | (~((C)))) ^ ((B))));
		D = (((D) << (10)) | (((D) & 0xffffffff) >> (32 - (10))));
		D += A;
	};;
	{
		C += ((X[10]) + (0xffeff47dL) + ((((D)) | (~((B)))) ^ ((A))));
		C = (((C) << (15)) | (((C) & 0xffffffff) >> (32 - (15))));
		C += D;
	};;
	{
		B += ((X[1]) + (0x85845dd1L) + ((((C)) | (~((A)))) ^ ((D))));
		B = (((B) << (21)) | (((B) & 0xffffffff) >> (32 - (21))));
		B += C;
	};;
	{
		A += ((X[8]) + (0x6fa87e4fL) + ((((B)) | (~((D)))) ^ ((C))));
		A = (((A) << (6)) | (((A) & 0xffffffff) >> (32 - (6))));
		A += B;
	};;
	{
		D += ((X[15]) + (0xfe2ce6e0L) + ((((A)) | (~((C)))) ^ ((B))));
		D = (((D) << (10)) | (((D) & 0xffffffff) >> (32 - (10))));
		D += A;
	};;
	{
		C += ((X[6]) + (0xa3014314L) + ((((D)) | (~((B)))) ^ ((A))));
		C = (((C) << (15)) | (((C) & 0xffffffff) >> (32 - (15))));
		C += D;
	};;
	{
		B += ((X[13]) + (0x4e0811a1L) + ((((C)) | (~((A)))) ^ ((D))));
		B = (((B) << (21)) | (((B) & 0xffffffff) >> (32 - (21))));
		B += C;
	};;
	{
		A += ((X[4]) + (0xf7537e82L) + ((((B)) | (~((D)))) ^ ((C))));
		A = (((A) << (6)) | (((A) & 0xffffffff) >> (32 - (6))));
		A += B;
	};;
	{
		D += ((X[11]) + (0xbd3af235L) + ((((A)) | (~((C)))) ^ ((B))));
		D = (((D) << (10)) | (((D) & 0xffffffff) >> (32 - (10))));
		D += A;
	};;
	{
		C += ((X[2]) + (0x2ad7d2bbL) + ((((D)) | (~((B)))) ^ ((A))));
		C = (((C) << (15)) | (((C) & 0xffffffff) >> (32 - (15))));
		C += D;
	};;
	{
		B += ((X[9]) + (0xeb86d391L) + ((((C)) | (~((A)))) ^ ((D))));
		B = (((B) << (21)) | (((B) & 0xffffffff) >> (32 - (21))));
		B += C;
	};;

	c->A += A & 0xffffffffL;
	c->B += B & 0xffffffffL;
	c->C += C & 0xffffffffL;
	c->D += D & 0xffffffffL;
}

void
MD5Final(MD5_CTX * c, unsigned char *md)
{
	register int i, j;
	register unsigned long l;
	register unsigned long *p;
	static unsigned char end[4] = { 0x80, 0x00, 0x00, 0x00 };
	unsigned char *cp = end;

	p = c->data;
	j = c->num;
	i = j >> 2;
	if ((j & 0x03) == 0)
		p[i] = 0;
	l = p[i];
	{
		switch (j & 0x03) {
		case 0:
			l = ((unsigned long) (*((cp)++)));
		case 1:
			l |= ((unsigned long) (*((cp)++))) << 8;
		case 2:
			l |= ((unsigned long) (*((cp)++))) << 16;
		case 3:
			l |= ((unsigned long) (*((cp)++))) << 24;
	}};
	p[i] = l;
	i++;

	if (c->num >= 56) {
		for (; i < 16; i++)
			p[i] = 0;
		md5_block(c, p);
		i = 0;
	}
	for (; i < (16 - 2); i++)
		p[i] = 0;
	p[16 - 2] = c->Nl;
	p[16 - 1] = c->Nh;
	md5_block(c, p);
	cp = md;
	l = c->A;
	(*((cp)++) = (unsigned char) (((l)) & 0xff), *((cp)++) =
	 (unsigned char) (((l) >> 8) & 0xff), *((cp)++) =
	 (unsigned char) (((l) >> 16) & 0xff), *((cp)++) =
	 (unsigned char) (((l) >> 24) & 0xff));
	l = c->B;
	(*((cp)++) = (unsigned char) (((l)) & 0xff), *((cp)++) =
	 (unsigned char) (((l) >> 8) & 0xff), *((cp)++) =
	 (unsigned char) (((l) >> 16) & 0xff), *((cp)++) =
	 (unsigned char) (((l) >> 24) & 0xff));
	l = c->C;
	(*((cp)++) = (unsigned char) (((l)) & 0xff), *((cp)++) =
	 (unsigned char) (((l) >> 8) & 0xff), *((cp)++) =
	 (unsigned char) (((l) >> 16) & 0xff), *((cp)++) =
	 (unsigned char) (((l) >> 24) & 0xff));
	l = c->D;
	(*((cp)++) = (unsigned char) (((l)) & 0xff), *((cp)++) =
	 (unsigned char) (((l) >> 8) & 0xff), *((cp)++) =
	 (unsigned char) (((l) >> 16) & 0xff), *((cp)++) =
	 (unsigned char) (((l) >> 24) & 0xff));

	c->num = 0;

}

typedef unsigned char des_cblock[8];
typedef struct des_ks_struct {
	union {
		des_cblock _;
		unsigned long pad[2];
	} ks;

} des_key_schedule[16];

static const unsigned long SPtrans[8][64] = {
       {0x00820200, 0x00020000, 0x80800000, 0x80820200,
	0x00800000, 0x80020200, 0x80020000, 0x80800000,
	0x80020200, 0x00820200, 0x00820000, 0x80000200,
	0x80800200, 0x00800000, 0x00000000, 0x80020000,
	0x00020000, 0x80000000, 0x00800200, 0x00020200,
	0x80820200, 0x00820000, 0x80000200, 0x00800200,
	0x80000000, 0x00000200, 0x00020200, 0x80820000,
	0x00000200, 0x80800200, 0x80820000, 0x00000000,
	0x00000000, 0x80820200, 0x00800200, 0x80020000,
	0x00820200, 0x00020000, 0x80000200, 0x00800200,
	0x80820000, 0x00000200, 0x00020200, 0x80800000,
	0x80020200, 0x80000000, 0x80800000, 0x00820000,
	0x80820200, 0x00020200, 0x00820000, 0x80800200,
	0x00800000, 0x80000200, 0x80020000, 0x00000000,
	0x00020000, 0x00800000, 0x80800200, 0x00820200,
	0x80000000, 0x80820000, 0x00000200, 0x80020200},

       {0x10042004, 0x00000000, 0x00042000, 0x10040000,
	0x10000004, 0x00002004, 0x10002000, 0x00042000,
	0x00002000, 0x10040004, 0x00000004, 0x10002000,
	0x00040004, 0x10042000, 0x10040000, 0x00000004,
	0x00040000, 0x10002004, 0x10040004, 0x00002000,
	0x00042004, 0x10000000, 0x00000000, 0x00040004,
	0x10002004, 0x00042004, 0x10042000, 0x10000004,
	0x10000000, 0x00040000, 0x00002004, 0x10042004,
	0x00040004, 0x10042000, 0x10002000, 0x00042004,
	0x10042004, 0x00040004, 0x10000004, 0x00000000,
	0x10000000, 0x00002004, 0x00040000, 0x10040004,
	0x00002000, 0x10000000, 0x00042004, 0x10002004,
	0x10042000, 0x00002000, 0x00000000, 0x10000004,
	0x00000004, 0x10042004, 0x00042000, 0x10040000,
	0x10040004, 0x00040000, 0x00002004, 0x10002000,
	0x10002004, 0x00000004, 0x10040000, 0x00042000},

       {0x41000000, 0x01010040, 0x00000040, 0x41000040,
	0x40010000, 0x01000000, 0x41000040, 0x00010040,
	0x01000040, 0x00010000, 0x01010000, 0x40000000,
	0x41010040, 0x40000040, 0x40000000, 0x41010000,
	0x00000000, 0x40010000, 0x01010040, 0x00000040,
	0x40000040, 0x41010040, 0x00010000, 0x41000000,
	0x41010000, 0x01000040, 0x40010040, 0x01010000,
	0x00010040, 0x00000000, 0x01000000, 0x40010040,
	0x01010040, 0x00000040, 0x40000000, 0x00010000,
	0x40000040, 0x40010000, 0x01010000, 0x41000040,
	0x00000000, 0x01010040, 0x00010040, 0x41010000,
	0x40010000, 0x01000000, 0x41010040, 0x40000000,
	0x40010040, 0x41000000, 0x01000000, 0x41010040,
	0x00010000, 0x01000040, 0x41000040, 0x00010040,
	0x01000040, 0x00000000, 0x41010000, 0x40000040,
	0x41000000, 0x40010040, 0x00000040, 0x01010000},

       {0x00100402, 0x04000400, 0x00000002, 0x04100402,
	0x00000000, 0x04100000, 0x04000402, 0x00100002,
	0x04100400, 0x04000002, 0x04000000, 0x00000402,
	0x04000002, 0x00100402, 0x00100000, 0x04000000,
	0x04100002, 0x00100400, 0x00000400, 0x00000002,
	0x00100400, 0x04000402, 0x04100000, 0x00000400,
	0x00000402, 0x00000000, 0x00100002, 0x04100400,
	0x04000400, 0x04100002, 0x04100402, 0x00100000,
	0x04100002, 0x00000402, 0x00100000, 0x04000002,
	0x00100400, 0x04000400, 0x00000002, 0x04100000,
	0x04000402, 0x00000000, 0x00000400, 0x00100002,
	0x00000000, 0x04100002, 0x04100400, 0x00000400,
	0x04000000, 0x04100402, 0x00100402, 0x00100000,
	0x04100402, 0x00000002, 0x04000400, 0x00100402,
	0x00100002, 0x00100400, 0x04100000, 0x04000402,
	0x00000402, 0x04000000, 0x04000002, 0x04100400},

       {0x02000000, 0x00004000, 0x00000100, 0x02004108,
	0x02004008, 0x02000100, 0x00004108, 0x02004000,
	0x00004000, 0x00000008, 0x02000008, 0x00004100,
	0x02000108, 0x02004008, 0x02004100, 0x00000000,
	0x00004100, 0x02000000, 0x00004008, 0x00000108,
	0x02000100, 0x00004108, 0x00000000, 0x02000008,
	0x00000008, 0x02000108, 0x02004108, 0x00004008,
	0x02004000, 0x00000100, 0x00000108, 0x02004100,
	0x02004100, 0x02000108, 0x00004008, 0x02004000,
	0x00004000, 0x00000008, 0x02000008, 0x02000100,
	0x02000000, 0x00004100, 0x02004108, 0x00000000,
	0x00004108, 0x02000000, 0x00000100, 0x00004008,
	0x02000108, 0x00000100, 0x00000000, 0x02004108,
	0x02004008, 0x02004100, 0x00000108, 0x00004000,
	0x00004100, 0x02004008, 0x02000100, 0x00000108,
	0x00000008, 0x00004108, 0x02004000, 0x02000008},

       {0x20000010, 0x00080010, 0x00000000, 0x20080800,
	0x00080010, 0x00000800, 0x20000810, 0x00080000,
	0x00000810, 0x20080810, 0x00080800, 0x20000000,
	0x20000800, 0x20000010, 0x20080000, 0x00080810,
	0x00080000, 0x20000810, 0x20080010, 0x00000000,
	0x00000800, 0x00000010, 0x20080800, 0x20080010,
	0x20080810, 0x20080000, 0x20000000, 0x00000810,
	0x00000010, 0x00080800, 0x00080810, 0x20000800,
	0x00000810, 0x20000000, 0x20000800, 0x00080810,
	0x20080800, 0x00080010, 0x00000000, 0x20000800,
	0x20000000, 0x00000800, 0x20080010, 0x00080000,
	0x00080010, 0x20080810, 0x00080800, 0x00000010,
	0x20080810, 0x00080800, 0x00080000, 0x20000810,
	0x20000010, 0x20080000, 0x00080810, 0x00000000,
	0x00000800, 0x20000010, 0x20000810, 0x20080800,
	0x20080000, 0x00000810, 0x00000010, 0x20080010},

       {0x00001000, 0x00000080, 0x00400080, 0x00400001,
	0x00401081, 0x00001001, 0x00001080, 0x00000000,
	0x00400000, 0x00400081, 0x00000081, 0x00401000,
	0x00000001, 0x00401080, 0x00401000, 0x00000081,
	0x00400081, 0x00001000, 0x00001001, 0x00401081,
	0x00000000, 0x00400080, 0x00400001, 0x00001080,
	0x00401001, 0x00001081, 0x00401080, 0x00000001,
	0x00001081, 0x00401001, 0x00000080, 0x00400000,
	0x00001081, 0x00401000, 0x00401001, 0x00000081,
	0x00001000, 0x00000080, 0x00400000, 0x00401001,
	0x00400081, 0x00001081, 0x00001080, 0x00000000,
	0x00000080, 0x00400001, 0x00000001, 0x00400080,
	0x00000000, 0x00400081, 0x00400080, 0x00001080,
	0x00000081, 0x00001000, 0x00401081, 0x00400000,
	0x00401080, 0x00000001, 0x00001001, 0x00401081,
	0x00400001, 0x00401080, 0x00401000, 0x00001001},

       {0x08200020, 0x08208000, 0x00008020, 0x00000000,
	0x08008000, 0x00200020, 0x08200000, 0x08208020,
	0x00000020, 0x08000000, 0x00208000, 0x00008020,
	0x00208020, 0x08008020, 0x08000020, 0x08200000,
	0x00008000, 0x00208020, 0x00200020, 0x08008000,
	0x08208020, 0x08000020, 0x00000000, 0x00208000,
	0x08000000, 0x00200000, 0x08008020, 0x08200020,
	0x00200000, 0x00008000, 0x08208000, 0x00000020,
	0x00200000, 0x00008000, 0x08000020, 0x08208020,
	0x00008020, 0x08000000, 0x00000000, 0x00208000,
	0x08200020, 0x08008020, 0x08008000, 0x00200020,
	0x08208000, 0x00000020, 0x00200020, 0x08008000,
	0x08208020, 0x00200000, 0x08200000, 0x08000020,
	0x00208000, 0x00008020, 0x08008020, 0x08200000,
	0x00000020, 0x08208000, 0x00208020, 0x00000000,
	0x08000000, 0x08200020, 0x00008000, 0x00208020}
};

static const unsigned long skb[8][64] = {
       {0x00000000, 0x00000010, 0x20000000, 0x20000010,
	0x00010000, 0x00010010, 0x20010000, 0x20010010,
	0x00000800, 0x00000810, 0x20000800, 0x20000810,
	0x00010800, 0x00010810, 0x20010800, 0x20010810,
	0x00000020, 0x00000030, 0x20000020, 0x20000030,
	0x00010020, 0x00010030, 0x20010020, 0x20010030,
	0x00000820, 0x00000830, 0x20000820, 0x20000830,
	0x00010820, 0x00010830, 0x20010820, 0x20010830,
	0x00080000, 0x00080010, 0x20080000, 0x20080010,
	0x00090000, 0x00090010, 0x20090000, 0x20090010,
	0x00080800, 0x00080810, 0x20080800, 0x20080810,
	0x00090800, 0x00090810, 0x20090800, 0x20090810,
	0x00080020, 0x00080030, 0x20080020, 0x20080030,
	0x00090020, 0x00090030, 0x20090020, 0x20090030,
	0x00080820, 0x00080830, 0x20080820, 0x20080830,
	0x00090820, 0x00090830, 0x20090820, 0x20090830},

       {0x00000000, 0x02000000, 0x00002000, 0x02002000,
	0x00200000, 0x02200000, 0x00202000, 0x02202000,
	0x00000004, 0x02000004, 0x00002004, 0x02002004,
	0x00200004, 0x02200004, 0x00202004, 0x02202004,
	0x00000400, 0x02000400, 0x00002400, 0x02002400,
	0x00200400, 0x02200400, 0x00202400, 0x02202400,
	0x00000404, 0x02000404, 0x00002404, 0x02002404,
	0x00200404, 0x02200404, 0x00202404, 0x02202404,
	0x10000000, 0x12000000, 0x10002000, 0x12002000,
	0x10200000, 0x12200000, 0x10202000, 0x12202000,
	0x10000004, 0x12000004, 0x10002004, 0x12002004,
	0x10200004, 0x12200004, 0x10202004, 0x12202004,
	0x10000400, 0x12000400, 0x10002400, 0x12002400,
	0x10200400, 0x12200400, 0x10202400, 0x12202400,
	0x10000404, 0x12000404, 0x10002404, 0x12002404,
	0x10200404, 0x12200404, 0x10202404, 0x12202404},

       {0x00000000, 0x00000001, 0x00040000, 0x00040001,
	0x01000000, 0x01000001, 0x01040000, 0x01040001,
	0x00000002, 0x00000003, 0x00040002, 0x00040003,
	0x01000002, 0x01000003, 0x01040002, 0x01040003,
	0x00000200, 0x00000201, 0x00040200, 0x00040201,
	0x01000200, 0x01000201, 0x01040200, 0x01040201,
	0x00000202, 0x00000203, 0x00040202, 0x00040203,
	0x01000202, 0x01000203, 0x01040202, 0x01040203,
	0x08000000, 0x08000001, 0x08040000, 0x08040001,
	0x09000000, 0x09000001, 0x09040000, 0x09040001,
	0x08000002, 0x08000003, 0x08040002, 0x08040003,
	0x09000002, 0x09000003, 0x09040002, 0x09040003,
	0x08000200, 0x08000201, 0x08040200, 0x08040201,
	0x09000200, 0x09000201, 0x09040200, 0x09040201,
	0x08000202, 0x08000203, 0x08040202, 0x08040203,
	0x09000202, 0x09000203, 0x09040202, 0x09040203},

       {0x00000000, 0x00100000, 0x00000100, 0x00100100,
	0x00000008, 0x00100008, 0x00000108, 0x00100108,
	0x00001000, 0x00101000, 0x00001100, 0x00101100,
	0x00001008, 0x00101008, 0x00001108, 0x00101108,
	0x04000000, 0x04100000, 0x04000100, 0x04100100,
	0x04000008, 0x04100008, 0x04000108, 0x04100108,
	0x04001000, 0x04101000, 0x04001100, 0x04101100,
	0x04001008, 0x04101008, 0x04001108, 0x04101108,
	0x00020000, 0x00120000, 0x00020100, 0x00120100,
	0x00020008, 0x00120008, 0x00020108, 0x00120108,
	0x00021000, 0x00121000, 0x00021100, 0x00121100,
	0x00021008, 0x00121008, 0x00021108, 0x00121108,
	0x04020000, 0x04120000, 0x04020100, 0x04120100,
	0x04020008, 0x04120008, 0x04020108, 0x04120108,
	0x04021000, 0x04121000, 0x04021100, 0x04121100,
	0x04021008, 0x04121008, 0x04021108, 0x04121108},

       {0x00000000, 0x10000000, 0x00010000, 0x10010000,
	0x00000004, 0x10000004, 0x00010004, 0x10010004,
	0x20000000, 0x30000000, 0x20010000, 0x30010000,
	0x20000004, 0x30000004, 0x20010004, 0x30010004,
	0x00100000, 0x10100000, 0x00110000, 0x10110000,
	0x00100004, 0x10100004, 0x00110004, 0x10110004,
	0x20100000, 0x30100000, 0x20110000, 0x30110000,
	0x20100004, 0x30100004, 0x20110004, 0x30110004,
	0x00001000, 0x10001000, 0x00011000, 0x10011000,
	0x00001004, 0x10001004, 0x00011004, 0x10011004,
	0x20001000, 0x30001000, 0x20011000, 0x30011000,
	0x20001004, 0x30001004, 0x20011004, 0x30011004,
	0x00101000, 0x10101000, 0x00111000, 0x10111000,
	0x00101004, 0x10101004, 0x00111004, 0x10111004,
	0x20101000, 0x30101000, 0x20111000, 0x30111000,
	0x20101004, 0x30101004, 0x20111004, 0x30111004},

       {0x00000000, 0x08000000, 0x00000008, 0x08000008,
	0x00000400, 0x08000400, 0x00000408, 0x08000408,
	0x00020000, 0x08020000, 0x00020008, 0x08020008,
	0x00020400, 0x08020400, 0x00020408, 0x08020408,
	0x00000001, 0x08000001, 0x00000009, 0x08000009,
	0x00000401, 0x08000401, 0x00000409, 0x08000409,
	0x00020001, 0x08020001, 0x00020009, 0x08020009,
	0x00020401, 0x08020401, 0x00020409, 0x08020409,
	0x02000000, 0x0A000000, 0x02000008, 0x0A000008,
	0x02000400, 0x0A000400, 0x02000408, 0x0A000408,
	0x02020000, 0x0A020000, 0x02020008, 0x0A020008,
	0x02020400, 0x0A020400, 0x02020408, 0x0A020408,
	0x02000001, 0x0A000001, 0x02000009, 0x0A000009,
	0x02000401, 0x0A000401, 0x02000409, 0x0A000409,
	0x02020001, 0x0A020001, 0x02020009, 0x0A020009,
	0x02020401, 0x0A020401, 0x02020409, 0x0A020409},

       {0x00000000, 0x00000100, 0x00080000, 0x00080100,
	0x01000000, 0x01000100, 0x01080000, 0x01080100,
	0x00000010, 0x00000110, 0x00080010, 0x00080110,
	0x01000010, 0x01000110, 0x01080010, 0x01080110,
	0x00200000, 0x00200100, 0x00280000, 0x00280100,
	0x01200000, 0x01200100, 0x01280000, 0x01280100,
	0x00200010, 0x00200110, 0x00280010, 0x00280110,
	0x01200010, 0x01200110, 0x01280010, 0x01280110,
	0x00000200, 0x00000300, 0x00080200, 0x00080300,
	0x01000200, 0x01000300, 0x01080200, 0x01080300,
	0x00000210, 0x00000310, 0x00080210, 0x00080310,
	0x01000210, 0x01000310, 0x01080210, 0x01080310,
	0x00200200, 0x00200300, 0x00280200, 0x00280300,
	0x01200200, 0x01200300, 0x01280200, 0x01280300,
	0x00200210, 0x00200310, 0x00280210, 0x00280310,
	0x01200210, 0x01200310, 0x01280210, 0x01280310},

       {0x00000000, 0x04000000, 0x00040000, 0x04040000,
	0x00000002, 0x04000002, 0x00040002, 0x04040002,
	0x00002000, 0x04002000, 0x00042000, 0x04042000,
	0x00002002, 0x04002002, 0x00042002, 0x04042002,
	0x00000020, 0x04000020, 0x00040020, 0x04040020,
	0x00000022, 0x04000022, 0x00040022, 0x04040022,
	0x00002020, 0x04002020, 0x00042020, 0x04042020,
	0x00002022, 0x04002022, 0x00042022, 0x04042022,
	0x00000800, 0x04000800, 0x00040800, 0x04040800,
	0x00000802, 0x04000802, 0x00040802, 0x04040802,
	0x00002800, 0x04002800, 0x00042800, 0x04042800,
	0x00002802, 0x04002802, 0x00042802, 0x04042802,
	0x00000820, 0x04000820, 0x00040820, 0x04040820,
	0x00000822, 0x04000822, 0x00040822, 0x04040822,
	0x00002820, 0x04002820, 0x00042820, 0x04042820,
	0x00002822, 0x04002822, 0x00042822, 0x04042822}
};

static const char shifts2[16] =
    { 0, 0, 1, 1, 1, 1, 1, 1, 0, 1, 1, 1, 1, 1, 1, 0 };
static int
des_set_key(des_cblock * key, struct des_ks_struct *schedule)
{
	register unsigned long c, d, t, s;
	register unsigned char *in;
	register unsigned long *k;
	register int i;

	k = (unsigned long *) schedule;
	in = (unsigned char *) key;
	(c = ((unsigned long) (*((in)++))), c |=
	 ((unsigned long) (*((in)++))) << 8, c |=
	 ((unsigned long) (*((in)++))) << 16, c |=
	 ((unsigned long) (*((in)++))) << 24);
	(d = ((unsigned long) (*((in)++))), d |=
	 ((unsigned long) (*((in)++))) << 8, d |=
	 ((unsigned long) (*((in)++))) << 16, d |=
	 ((unsigned long) (*((in)++))) << 24);
	((t) = ((((d) >> (4)) ^ (c)) & (0x0f0f0f0f)), (c) ^= (t), (d) ^=
	 ((t) << (4)));
	((t) = ((((c) << (16 - (-2))) ^ (c)) & (0xcccc0000)), (c) =
	 (c) ^ (t) ^ (t >> (16 - (-2))));
	((t) = ((((d) << (16 - (-2))) ^ (d)) & (0xcccc0000)), (d) =
	 (d) ^ (t) ^ (t >> (16 - (-2))));
	((t) = ((((d) >> (1)) ^ (c)) & (0x55555555)), (c) ^= (t), (d) ^=
	 ((t) << (1)));
	((t) = ((((c) >> (8)) ^ (d)) & (0x00ff00ff)), (d) ^= (t), (c) ^=
	 ((t) << (8)));
	((t) = ((((d) >> (1)) ^ (c)) & (0x55555555)), (c) ^= (t), (d) ^=
	 ((t) << (1)));
	d = (((d & 0x000000ff) << 16) | (d & 0x0000ff00) |
	     ((d & 0x00ff0000) >> 16) | ((c & 0xf0000000) >> 4));
	c &= 0x0fffffff;
	for (i = 0; i < 16; i++) {
		if (shifts2[i]) {
			c = ((c >> 2) | (c << 26));
			d = ((d >> 2) | (d << 26));
		} else {
			c = ((c >> 1) | (c << 27));
			d = ((d >> 1) | (d << 27));
		}
		c &= 0x0fffffff;
		d &= 0x0fffffff;
		s = skb[0][(c) & 0x3f] |
		    skb[1][((c >> 6) & 0x03) | ((c >> 7) & 0x3c)] |
		    skb[2][((c >> 13) & 0x0f) | ((c >> 14) & 0x30)] |
		    skb[3][((c >> 20) & 0x01) | ((c >> 21) & 0x06) |
			   ((c >> 22) & 0x38)];
		t = skb[4][(d) & 0x3f] |
		    skb[5][((d >> 7) & 0x03) | ((d >> 8) & 0x3c)] |
		    skb[6][(d >> 15) & 0x3f] |
		    skb[7][((d >> 21) & 0x0f) | ((d >> 22) & 0x30)];

		*(k++) = ((t << 16) | (s & 0x0000ffff)) & 0xffffffff;
		s = ((s >> 16) | (t & 0xffff0000));

		s = (s << 4) | (s >> 28);
		*(k++) = s & 0xffffffff;
	}
	return 0;
}

static unsigned const char con_salt[128] = {
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01,
	0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09,
	0x0A, 0x0B, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0A,
	0x0B, 0x0C, 0x0D, 0x0E, 0x0F, 0x10, 0x11, 0x12,
	0x13, 0x14, 0x15, 0x16, 0x17, 0x18, 0x19, 0x1A,
	0x1B, 0x1C, 0x1D, 0x1E, 0x1F, 0x20, 0x21, 0x22,
	0x23, 0x24, 0x25, 0x20, 0x21, 0x22, 0x23, 0x24,
	0x25, 0x26, 0x27, 0x28, 0x29, 0x2A, 0x2B, 0x2C,
	0x2D, 0x2E, 0x2F, 0x30, 0x31, 0x32, 0x33, 0x34,
	0x35, 0x36, 0x37, 0x38, 0x39, 0x3A, 0x3B, 0x3C,
	0x3D, 0x3E, 0x3F, 0x00, 0x00, 0x00, 0x00, 0x00,
};

static unsigned const char cov_2char[64] = {
	0x2E, 0x2F, 0x30, 0x31, 0x32, 0x33, 0x34, 0x35,
	0x36, 0x37, 0x38, 0x39, 0x41, 0x42, 0x43, 0x44,
	0x45, 0x46, 0x47, 0x48, 0x49, 0x4A, 0x4B, 0x4C,
	0x4D, 0x4E, 0x4F, 0x50, 0x51, 0x52, 0x53, 0x54,
	0x55, 0x56, 0x57, 0x58, 0x59, 0x5A, 0x61, 0x62,
	0x63, 0x64, 0x65, 0x66, 0x67, 0x68, 0x69, 0x6A,
	0x6B, 0x6C, 0x6D, 0x6E, 0x6F, 0x70, 0x71, 0x72,
	0x73, 0x74, 0x75, 0x76, 0x77, 0x78, 0x79, 0x7A
};

static int
body(unsigned long *out0, unsigned long *out1, des_key_schedule ks,
     unsigned long Eswap0, unsigned long Eswap1)
{
	register unsigned long l, r, t, u;
	register unsigned long *s;
	register int i, j;
	register unsigned long E0, E1;

	l = 0;
	r = 0;
	s = (unsigned long *) ks;
	E0 = Eswap0;
	E1 = Eswap1;
	for (j = 0; j < 25; j++) {
		for (i = 0; i < (16 * 2); i += 4) {
			t = (r ^ (r >> 16));
			u = (t & E0);
			t = (t & E1);
			u = (u ^ (u << 16)) ^ r ^ s[i];
			t = (t ^ (t << 16)) ^ r ^ s[i + 1];
			t = (t >> 4) | (t << 28);
			l ^= SPtrans[1][(t) & 0x3f] | SPtrans[3][(t >> 8) &
								 0x3f] |
			    SPtrans[5][(t >> 16) & 0x3f] | SPtrans[7][(t >> 24)
								      & 0x3f] |
			    SPtrans[0][(u) & 0x3f] | SPtrans[2][(u >> 8) & 0x3f]
			    | SPtrans[4][(u >> 16) & 0x3f] |
			    SPtrans[6][(u >> 24) & 0x3f];
			t = (l ^ (l >> 16));
			u = (t & E0);
			t = (t & E1);
			u = (u ^ (u << 16)) ^ l ^ s[i + 2];
			t = (t ^ (t << 16)) ^ l ^ s[i + 2 + 1];
			t = (t >> 4) | (t << 28);
			r ^= SPtrans[1][(t) & 0x3f] | SPtrans[3][(t >> 8) &
								 0x3f] |
			    SPtrans[5][(t >> 16) & 0x3f] | SPtrans[7][(t >> 24)
								      & 0x3f] |
			    SPtrans[0][(u) & 0x3f] | SPtrans[2][(u >> 8) & 0x3f]
			    | SPtrans[4][(u >> 16) & 0x3f] |
			    SPtrans[6][(u >> 24) & 0x3f];
		}
		t = l;
		l = r;
		r = t;
	}
	t = r;
	r = (l >> 1) | (l << 31);
	l = (t >> 1) | (t << 31);
	l &= 0xffffffff;
	r &= 0xffffffff;
	((t) = ((((r) >> (1)) ^ (l)) & (0x55555555)), (l) ^= (t), (r) ^=
	 ((t) << (1)));
	((t) = ((((l) >> (8)) ^ (r)) & (0x00ff00ff)), (r) ^= (t), (l) ^=
	 ((t) << (8)));
	((t) = ((((r) >> (2)) ^ (l)) & (0x33333333)), (l) ^= (t), (r) ^=
	 ((t) << (2)));
	((t) = ((((l) >> (16)) ^ (r)) & (0x0000ffff)), (r) ^= (t), (l) ^=
	 ((t) << (16)));
	((t) = ((((r) >> (4)) ^ (l)) & (0x0f0f0f0f)), (l) ^= (t), (r) ^=
	 ((t) << (4)));
	*out0 = l;
	*out1 = r;
	return 0;
}

char *
crypt_des(char *buf, char *salt)
{
	unsigned int i, j, x, y;
	unsigned long Eswap0 = 0, Eswap1 = 0;
	unsigned long out[2], ll;
	des_cblock key;
	des_key_schedule ks;
	static unsigned char buff[20];
	unsigned char bb[9];
	unsigned char *b = bb;
	unsigned char c, u;

	x = buff[0] = ((salt[0] == '\0') ? 'A' : salt[0]);
	Eswap0 = con_salt[x];
	x = buff[1] = ((salt[1] == '\0') ? 'A' : salt[1]);
	Eswap1 = con_salt[x] << 4;
	for (i = 0; i < 8; i++) {
		c = *(buf++);
		if (!c)
			break;
		key[i] = (c << 1);
	}
	for (; i < 8; i++)
		key[i] = 0;
	des_set_key((des_cblock *) (key), ks);
	body(&(out[0]), &(out[1]), ks, Eswap0, Eswap1);
	ll = out[0];
	(*((b)++) = (unsigned char) (((ll)) & 0xff), *((b)++) =
	 (unsigned char) (((ll) >> 8) & 0xff), *((b)++) =
	 (unsigned char) (((ll) >> 16) & 0xff), *((b)++) =
	 (unsigned char) (((ll) >> 24) & 0xff));
	ll = out[1];
	(*((b)++) = (unsigned char) (((ll)) & 0xff), *((b)++) =
	 (unsigned char) (((ll) >> 8) & 0xff), *((b)++) =
	 (unsigned char) (((ll) >> 16) & 0xff), *((b)++) =
	 (unsigned char) (((ll) >> 24) & 0xff));
	y = 0;
	u = 0x80;
	bb[8] = 0;
	for (i = 2; i < 13; i++) {
		c = 0;
		for (j = 0; j < 6; j++) {
			c <<= 1;
			if (bb[y] & u)
				c |= 1;
			u >>= 1;
			if (!u) {
				y++;
				u = 0x80;
			}
		}
		buff[i] = cov_2char[c];
	}
	buff[13] = 0;
	return (char *) buff;
}
